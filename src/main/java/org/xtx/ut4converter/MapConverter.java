package org.xtx.ut4converter;

import javafx.concurrent.Task;
import javafx.scene.control.TableView;
import org.apache.commons.io.FilenameUtils;
import org.xtx.ut4converter.UTGames.UTGame;
import org.xtx.ut4converter.export.*;
import org.xtx.ut4converter.t3d.*;
import org.xtx.ut4converter.t3d.T3DRessource.Type;
import org.xtx.ut4converter.tools.Installation;
import org.xtx.ut4converter.tools.TextureDbFile;
import org.xtx.ut4converter.tools.UIUtils;
import org.xtx.ut4converter.tools.objmesh.ObjStaticMesh;
import org.xtx.ut4converter.tools.psk.Material;
import org.xtx.ut4converter.tools.psk.PSKStaticMesh;
import org.xtx.ut4converter.tools.t3dmesh.StaticMesh;
import org.xtx.ut4converter.tools.t3dmesh.Triangle;
import org.xtx.ut4converter.ucore.UPackage;
import org.xtx.ut4converter.ucore.UPackageRessource;
import org.xtx.ut4converter.ucore.UnrealEngine;
import org.xtx.ut4converter.ucore.UnrealGame;
import org.xtx.ut4converter.controller.ConversionViewController;
import org.xtx.ut4converter.controller.TableRowLog;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import static org.xtx.ut4converter.ucore.UnrealEngine.*;

/**
 *
 * @author XtremeXp
 */
@SuppressWarnings("restriction")
public class MapConverter extends Task<T3DLevelConvertor> {

	/**
	 * UT Game the map will be converted from
	 */
	private final UnrealGame inputGame;

	/**
	 * UT Game the map will be converted to
	 */
	private final UnrealGame outputGame;

	/**
	 * Default sub-folder of UT4 Converter where converted maps will be saved
	 */
	public static final String CONV_PATH = File.separator + "Converted";

	/**
	 * Input map. Can be either a map (.unr, ...) or unreal text map (.t3d)
	 */
	private File inMap;


	/**
	 * file writer of logfile
	 */
	private FileWriter logFileWriter;

	/**
	 * Buffered writer of logfile
	 */
	private BufferedWriter logBuffWriter;

	/**
	 * Final map name, might differ from original one. E.G: AS-Mazon (UT99) ->
	 * AS-Mazon-Original (for UT4 for exemple)
	 */
	private String mapName;


	/**
	 * getMapConvertFolder().getAbsolutePath() + File.separator + ressource.getType().getName() + File.separator
	 */
	private String ut4ReferenceBaseFolder;

	/**
	 * Input .t3d map file generated by UCC.exe
	 */
	private File inT3d;

	/**
	 * Output converted .t3d map file
	 */
	private File outT3d;

	/**
	 * Where all converted stuff will be converted
	 */
	private Path outPath;

	/**
	 * Scale factor applied to converted level.
	 */
	private double scale = 1d;

	/**
	 * Light map resolution
	 */
	private int lightMapResolution = 64;

	/**
	 * Quick converter of actor name. E.G: "Mover" (U1/UT99) -> "InterpActor"
	 * (UT3)
	 */
	private T3DMatch tm;

	/**
	 * Tells whether or not map is team based
	 */
	private Boolean isTeamGameType;

	/**
	 * TODO move this to T3D Level converter
	 */
	private SupportedClasses supportedActorClasses;

	/**
	 * T3d level converter
	 */
	private T3DLevelConvertor t3dLvlConvertor;

	/**
	 * Actor classes that should be converted. If null or empty then all classes
	 * will be converted.
	 */
	private String[] filteredClasses;

	/**
	 * If <code>true</code> textures of the map will be exported and converted.
	 */
	private boolean convertTextures = true;

	/**
	 * If <code>true</code> sounds of the map will be exported and converted
	 */
	private boolean convertSounds = true;

	/**
	 * Changes sound volume of sound actors. For exemple, if soundVolumeRatio <
	 * 100%, volume will be decreased
	 */
	public Float soundVolumeFactor;

	/**
	 * Scales radius of lights (default 1)
	 */
	public Float lightRadiusFactor;

	/**
	 * If <code>true</code> staticmeshes of the map will be exported and
	 * converted
	 */
	private boolean convertStaticMeshes = true;

	/**
	 * If <code>true</code> music of the map will be exported and converted
	 */
	private boolean convertMusic = true;

	/**
	 * Allow to extract packages. There should be always only one instanced
	 */
	public List<UTPackageExtractor> packageExtractors;

	public Collection<File> packageFilesCache = new ArrayList<>();

	/**
	 * Unreal packages used in map Can be sounds, textures, ...
	 */
	public Map<String, UPackage> mapPackages = new HashMap<>();



	/**
	 * If true will create notes for unconverted actors in level
	 */
	private boolean createNoteForUnconvertedActors = true;

	/**
	 * Reference to user interface
	 */
	ConversionViewController conversionViewController;

	/**
	 * If true, will make converted actors works
	 * with UB blueprints if needed.
	 */
	private boolean useUbClasses;

	/**
	 * If true, map converter is called not from ui (for batch tests)
	 */
	private boolean noUi;



	/**
	 * Global logger
	 */
	static final Logger logger = Logger.getLogger("MapConverter");

	/**
	 * For JUnit test purpose only.
	 * If it's true conversion process might be slightly different.
	 */
	public boolean isTestMode;

	/**
	 * Original UT game the map comes from
	 *
	 * @return Input unreal game
	 */
	public UnrealGame getInputGame() {
		return inputGame;
	}

	/**
	 * UT game the map will be converted to
	 *
	 * @return Output unreal game
	 */
	public UnrealGame getOutputGame() {
		return outputGame;
	}

	/**
	 * Input map that will be converted (Unreal Map (.unr, .ut2) or Unreal Text
	 * Map file (.t3d)
	 *
	 * @return Map file that is being converted (e.g: "C:/mymaps/CTF-Face.unr")
	 */
	public File getInMap() {
		return inMap;
	}

	/**
	 * Scale factor applied when converting
	 *
	 * @return Scale factor desired for map
	 */
	public double getScale() {
		return scale;
	}

	public int getLightMapResolution() {
		return lightMapResolution;
	}

	public void setLightMapResolution(int lightMapResolution) {
		this.lightMapResolution = lightMapResolution;
	}

	private ExportOption exportOption = ExportOption.BY_TYPE;

	/**
	 *
	 */
	public enum ExportOption {

		/**
		 * All resources might be imported for each type
		 * E.g:
		 * \Content\Converted\DM-Arcane-UT99\Textures
		 * \Content\Converted\DM-Arcane-UT99\Textures
		 */
		BY_TYPE("<MapName>/<Type>"),
		/**
		 * All resources might be imported by package
		 * E.g:
		 * \Content\Converted\DM-Arcane-UT99\GenEarth
		 * \Content\Converted\DM-Arcane-UT99\GenFluid
		 */
		BY_PACKAGE("<MapName>/<Package>");

		private final String label;


		ExportOption(String label) {
			this.label = label;
		}

		public String getLabel() {
			return label;
		}
	}

	/**
	 *
	 * @param inputGame
	 *            Input UT Game
	 * @param outputGame
	 *            Output UT Game
	 */
	public MapConverter(UnrealGame inputGame, UnrealGame outputGame) throws IOException {
		this.inputGame = inputGame;
		this.outputGame = outputGame;
		initialise();
	}

	/**
	 *
	 * @param inputGame
	 *            Input game the map originally comes from
	 * @param outputGame
	 *            Output game the map will be converted to
	 * @param inpMap
	 *            Map to be converted (either a t3d file or map)
	 * @param path Full path where to convert resource to
	 */
	public MapConverter(UnrealGame inputGame, UnrealGame outputGame, File inpMap, String path) throws IOException {
		this.inputGame = inputGame;
		this.outputGame = outputGame;
		this.inMap = inpMap;
		this.outPath = Paths.get(path);
		initialise();
	}


	/**
	 * Indicates that gametype is team based
	 *
	 * @return true is gametype is team based
	 */
	public Boolean isTeamGameType() {
		return isTeamGameType;
	}


	public void setIsTeamGameType(Boolean isTeamGameType) {
		this.isTeamGameType = isTeamGameType;
	}

	/**
	 * Search for an actor matching name and it's properties
	 *
	 * @param name Actor class name
	 * @param properties Properties
	 * @return Match if any
	 */
	public T3DMatch.Match getMatchFor(String name, Map<String, String> properties) {
		return tm.getMatchFor(name, inputGame, outputGame, properties);
	}


	public HashMap<String, T3DMatch.Match> getActorClassMatch() {
		return tm.getActorClassMatch(inputGame, outputGame);
	}

	private void initOutMapName() {
		if (mapName == null) {
			// TODO being able to set it manually (chosen by user)
			mapName = inMap.getName().split("\\.")[0] + "-" + inputGame.getShortName();

			// Remove bad chars from name (e.g: DM-Cybrosis][ -> DM-Cybrosis)
			// else ue4 editor won't be able to set sounds or textures to actors
			mapName = T3DUtils.filterName(mapName);
		}
	}

	public void initConvertedResourcesFolder(){
		initOutMapName();
		this.ut4ReferenceBaseFolder = UTGames.UE4_FOLDER_MAP + "/" + this.getOutMapName();
	}

	public void setUt4ReferenceBaseFolder (String folder){
		this.ut4ReferenceBaseFolder = folder;
	}

	public String getUt4ReferenceBaseFolder (){
		return this.ut4ReferenceBaseFolder;
	}

	public File getUt4ReferenceBaseFolderFile (){

		// e.g: ut4ReferenceBaseFolder = '/Game/RestrictedAssets/Map/DM-MyMap'
		String xx = ut4ReferenceBaseFolder;
		xx = xx.replace("/Game", "/Content");

		return new File(outputGame.getPath() + File.separator + "UnrealTournament" + File.separator + xx);
	}

	private void initialise() {

		if (this.outPath == null && inMap != null) {
			this.outPath = Paths.get(this.getMapConvertFolder().toURI());
		}


		tm = new T3DMatch(this);

		if (inMap != null) {
			if (inMap.getName().endsWith(".t3d")) {
				inT3d = inMap;
			}

			if (isTeamGameType == null) {
				isTeamGameType = UTGameTypes.isTeamBasedFromMapName(inT3d != null ? inT3d.getName() : inMap.getName());
			}

			initConvertedResourcesFolder();
		}

		supportedActorClasses = new SupportedClasses(this);


		// init available extractors
		packageExtractors = new ArrayList<>();
		packageExtractors.add(new UCCExporter(this));
		packageExtractors.add(new CopyExporter(this));
		packageExtractors.add(new SimpleTextureExtractor(this));
		packageExtractors.add(new UModelExporter(this));
	}

	/**
	 * All logs redirect to user interface thought table TODO write log file
	 */
	private void addLoggerHandlers() {


		if (conversionViewController == null || conversionViewController.getConvLogTableView() == null) {
			return;
		}

		conversionViewController.getProgressBar().progressProperty().bind(progressProperty());
		conversionViewController.getProgressIndicator().progressProperty().bind(progressProperty());
		conversionViewController.getProgressMessage().textProperty().bind(messageProperty());

		final TableView<TableRowLog> t = conversionViewController.getConvLogTableView();
		t.getItems().clear();

		logger.addHandler(new Handler() {

			@Override
			public void publish(LogRecord record) {
				if (logBuffWriter != null) {
					try {
						logBuffWriter.write(TableRowLog.sdf.format(new Date(record.getMillis())) + " - " + record.getLevel().getName() + " - " + TableRowLog.getMessageFormatted(record) + "\n");
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				t.getItems().add(new TableRowLog(record));
			}

			@Override
			public void flush() {
				t.getItems().clear();
			}

			@Override
			public void close() throws SecurityException {
				// nothing to do
			}
		});
	}

	final String UPK = "upk";

	/**
	 * Caches all .upk files list
	 * for unreal engine 3 maps
	 */
	private void initUe3PackageFilesCache() {

		packageFilesCache = org.apache.commons.io.FileUtils.listFiles(inputGame.getPath(), new String[]{UPK}, true);
		logger.info("Scanned " + packageFilesCache.size() + " .upk files");
	}

	/**
	 * Gets file container from .upk file
	 *
	 * @param packageName
	 *            Package Name (HU_Deco)
	 * @return File container of package (e.g: HU_Deco.upk)
	 */
	public File getUe3PackageFileFromName(final String packageName) {

		for (File upk : packageFilesCache) {

			if (upk.getName().toLowerCase().equals(packageName.toLowerCase() + "." + UPK) || upk.getName().toLowerCase().equals(packageName.toLowerCase() + "." + getInputGame().getMapExt())) {
				return upk;
			}
		}

		return null;
	}

	public static final long PROGRESS_BEFORE_CONVERT = 20;

	/**
	 * Converts level
	 *
	 * @throws Exception Exception thrown
	 */
	public void convert() throws Exception {


		try {
			Files.createDirectories(getTempExportFolder().toPath());

			// File for logging all events during conversion process
			File logFile = new File(outPath.toFile().getAbsolutePath() + File.separator + "conversion.log");

			if (logFile.exists()) {
				Files.delete(logFile.toPath());
			}

			Files.createDirectories(logFile.getParentFile().toPath());

			logFileWriter = new FileWriter(logFile);
			logBuffWriter = new BufferedWriter(logFileWriter);

			logger.log(Level.INFO, "Writting log file " + logFile);

			logger.log(Level.INFO, "*****************************************");
			System.out.println("Converting " + inMap.getAbsolutePath());
			logger.log(Level.INFO, MainApp.PROGRAM_NAME + " v" + MainApp.VERSION);
			logger.log(Level.INFO, "Conversion of " + inMap.getName() + " to " + outputGame.getName());
			logger.log(Level.INFO, "Scale Factor: " + scale + " Light Radius Factor: " + this.lightRadiusFactor);

			if (filteredClasses != null && filteredClasses.length > 0) {
				getSupportedActorClasses().setConvertOnly(filteredClasses);
				logger.log(Level.INFO, "Only these manually specified actor classes will be converted:");

				for (String className : filteredClasses) {
					logger.log(Level.INFO, "-" + className);
				}
			}

			updateProgress(0, 100);

			// UE1 games (but U1) may need to build texture db file to get packagename from texture name
			if (inputGame.isUseTexDb()) {
				logger.log(Level.INFO, "Generating or updating " + inputGame.getShortName() + " texture db file " + TextureDbFile.getTextureDbFileNameForGame(inputGame));
				TextureDbFile.createOrUpdateTexDbForGame(inputGame);
				this.gameTextureDb = TextureDbFile.loadTextureDbForGame(inputGame);
				updateProgress(5, 100);
			}

			if (isFrom(UE3)) {
				initUe3PackageFilesCache();
			}

			if (!outPath.toFile().exists()) {
				Files.createDirectories(outPath);
			}

			// Export unreal map to Unreal Text map
			if (inT3d == null) {
				updateProgress(10, 100);
				packageFilesCache.add(inMap);
				updateMessage("Exporting map to unreal text file");
				inT3d = UCCExporter.exportLevelToT3d(this, inMap);
			}

			updateProgress(PROGRESS_BEFORE_CONVERT, 100);
			outT3d = new File(outPath.toFile().getAbsolutePath() + File.separator + mapName + ".t3d");

			// t3d ever exported or directly converting from t3d file, then skip
			// export of it
			// and directly convert it
			t3dLvlConvertor = new T3DLevelConvertor(inT3d, outT3d, this, noUi);
			t3dLvlConvertor.setCreateNoteForUnconvertedActors(createNoteForUnconvertedActors);
			updateMessage("Converting " + inT3d.getName() + " -> " + outT3d.getName());
			t3dLvlConvertor.readConvertAndWrite();
			updateProgress(80, 100);

			// find used textures in staticmeshes and convert sm to .obj
			convertStaticMeshFiles();

			updateProgress(90, 100);
			cleanAndConvertRessources();

			updateProgress(100, 100);
			updateMessage("All done!");
			logger.log(Level.INFO, "Map was succesfully converted to " + getOutT3d().getAbsolutePath());

			if(!noUi) {
				UIUtils.openExplorer(getOutPath().toFile());
			}

			showInstructions();


			// logs converted actors
			// might be useful to find out if some actors are missing from level
			logBuffWriter.write("\n*** Converted actors ***\n");

			for (String actorClass : t3dLvlConvertor.getConvertedActors().stream().map(T3DObject::getT3dClass).distinct().sorted().toList()) {
				logBuffWriter.write("- " + actorClass + "\n");
			}

			writeUnconvertedActorsPropertiesToLogFile();
		} finally {
			if (logBuffWriter != null) {
				logBuffWriter.close();
			}

			if (logFileWriter != null) {
				logFileWriter.close();
			}
		}
	}

	protected void updateMessage(String message) {
		if(!noUi) {
			super.updateMessage(message);
		}
	}

	protected void updateProgress(long workDone, long max) {
		if(!noUi) {
			super.updateProgress((double) workDone, (double) max);
		}
	}

	public void updateMapConverterProgress(long workDone, long max){
		updateProgress(workDone, max);
	}

	/**
	 * Log to file all unconverted actors and properties of all actors from
	 * original map
	 *
	 * @throws IOException IO error
	 */
	private void writeUnconvertedActorsPropertiesToLogFile() throws IOException {

		logBuffWriter.write("\n*** Unconverted actors ***\n");

		for (String actorClass : t3dLvlConvertor.getUnconvertedActors()) {
			logBuffWriter.write("- " + actorClass + "\n");
		}

		logBuffWriter.write("\n*** Unconverted properties ***\n");

		for (String actorClass : t3dLvlConvertor.getUnconvertedProperties().keySet()) {
			logBuffWriter.write("*** " + actorClass + " ***\n");

			for (String property : t3dLvlConvertor.getUnconvertedProperties().get(actorClass)) {
				logBuffWriter.write("- " + property + "\n");
			}

			logBuffWriter.write("\n");
		}
	}

	/**
	 *
	 * rather than using this not very humain friendly 'basic text' instructions
	 */
	private void showInstructions() {


		logger.log(Level.INFO, "Go to github program wiki page for further instructions within UE editor");

		// for terrain from UE3 need to display the material as instructions
		if (isTo(UE4)) {

			logger.log(Level.INFO, "* Extra instructions *");

			// Unreal Engine 2 terrain information
			t3dLvlConvertor.getConvertedActors().stream().filter(e -> e instanceof T3DUE2Terrain || e instanceof T3DUE3Terrain).toList().forEach(actor -> {

				logger.log(Level.INFO, "For terrain " + actor.getName());

				if (actor instanceof T3DUE2Terrain ue2Terrain) {

					logger.log(Level.INFO, "Assign materials to landscape material in this order :");

					ue2Terrain.getLayers().forEach(terrainLayer -> {
						if (terrainLayer.getTexture() != null) {
							logger.log(Level.INFO, "Open " + terrainLayer.getTexture().getConvertedName());
						}
					});
				}
				// Terrain Layer Setups for UT3 editor
				else if (actor instanceof T3DUE3Terrain ue3Terrain) {
					logger.log(Level.INFO, "Assign materials to landscape material from TerrainLayerSetups in UT3 editor :");

					ue3Terrain.getTerrainLayers().forEach(terrainLayer -> logger.log(Level.INFO, terrainLayer.getTerrainLayerSetupName()));
				}

			});
		}

		logger.log(Level.INFO, "Check the conversion wiki page for further instructions.");
	}


	/**
	 * Convert staticmeshes files used in map to proper format (.ase for UE3, .obj for UE4+)
	 * Rename texture in staticmeshes to fit with UE4+ convention (<packagename>_<group>_<name>_mat) or UE3 convention
	 * Export textures used in staticmeshes (if they have not been ever exported)
	 */
	private void convertStaticMeshFiles()  {

		final String msg = "Identifying staticmeshes textures";
		updateMessage(msg);
		logger.log(Level.INFO, msg);

		// have to make a copy to avoid concurrentmodification exception
		// (some new packages might be identified)
		final Map<String, UPackage> mapPackagesCopy = new LinkedHashMap<>(mapPackages);

		// get list of staticmeshes used in map
		final List<UPackageRessource> smPkgResUsedList = mapPackagesCopy.values().stream().map(UPackage::getRessources).flatMap(Set::stream).filter(r -> r.isUsedInMap() && r.getType() == Type.STATICMESH).toList();

		for (final UPackageRessource smPkgResUsed : smPkgResUsedList) {

			// e.g: /Converted/ONS-Dria/SkyBoxCylinder.pskx
			final File smFile = smPkgResUsed.getExportInfo().getExportedFileByExtension(PSKStaticMesh.FILE_EXTENSION_PSKX, PSKStaticMesh.FILE_EXTENSION_PSK, StaticMesh.FILE_EXTENSION_T3D);

			if (smFile == null || !smFile.exists()) {
				continue;
			}

			final String smFileExt = FilenameUtils.getExtension(smFile.getName());
			// e.g: /Converted/ONS-Dria/SkyBoxCylinder
			final String smConvFileBaseName = smFile.getParent() + "/" + smFile.getName().substring(0, smFile.getName().lastIndexOf("."));
			final File smObjFile = new File(smConvFileBaseName + ".obj");
			final File smMtlFile = new File(smConvFileBaseName + ".mtl");
			final File smAseFile = new File(smConvFileBaseName + ".ase");

			try {
				// .psk(x) -> .obj + .mtl (UE4+) / .ase (UE3) conversion
				if (PSKStaticMesh.FILE_EXTENSION_PSK.equals(smFileExt) || PSKStaticMesh.FILE_EXTENSION_PSKX.equals(smFileExt)) {
					final PSKStaticMesh pskSm = new PSKStaticMesh(smFile);
					pskSm.replaceMaterialNamesBy(getReplacementMatName(pskSm.getMaterials().stream().map(Material::getMaterialName).toList()));

					if (isTo(UE4, UE5)) {
						pskSm.exportToObj(smMtlFile, smObjFile);
					} else if (isTo(UE3)) {
						pskSm.exportToAse(smAseFile);
					}
				}
				// .t3d -> .obj + .mtl (UE4+) / .ase (UE3) conversion
				else if (StaticMesh.FILE_EXTENSION_T3D.equals(smFileExt)) {
					final StaticMesh smT3dFile = new StaticMesh(smFile);
					smT3dFile.replaceMaterialNamesBy(getReplacementMatName(smT3dFile.getTriangles().stream().map(Triangle::getTexture).toList()));

					if (isTo(UE4, UE5)) {
						new ObjStaticMesh(smT3dFile).export(smMtlFile, smObjFile);
					} else if (isTo(UE3)) {
						smT3dFile.exportToAse(smAseFile);
					}
				}

				logger.info("Converting " + smFile.getName() + " -> " + ((smObjFile.length() > 0) ? smObjFile.getName() : "") + ((smAseFile.length() > 0) ? smAseFile.getName() : ""));
				smPkgResUsed.addExportedFiles(smObjFile, smMtlFile, smAseFile);
			} catch (Exception e) {
				logger.log(Level.WARNING, "Error converting " + smFile, e);
			}
		}

		// export textures being used in staticmeshes
		// if they have not ever been exported
		for (final UPackageRessource matRessource : pendingExport) {

			if (!matRessource.isExported() && this.convertTextures()) {
				matRessource.export(UTPackageExtractor.getExtractor(this, matRessource));
			}
		}
	}


	private Map<String, String> getReplacementMatName(List<String> materialNameList){

		Map<String, String> matNameToNewName = new HashMap<>();

		for(String matName : materialNameList){
			matNameToNewName.put(matName, listMatAndGetNewMatName(matName));
		}

		return matNameToNewName;
	}

	final List<UPackageRessource> pendingExport = new ArrayList<>();

	/**
	 *
	 * @param matName Staticmesh material name
	 * @return New material name if ressource exists
	 */
	private String listMatAndGetNewMatName(final String matName) {

		if (matName != null) {
			UPackageRessource matRessource;

			// material name containing full info packagename.group.name
			if(matName.contains(".")){
				matRessource = getUPackageRessource(matName, Type.TEXTURE);
			}
			// material name without package and group info
			else {
				matRessource = findRessourceByNameOnly(matName, Type.TEXTURE);
			}

            if (matRessource != null) {

                // try replace shader with diffuse texture
                if (matRessource.getMaterialInfo() != null) {
                    matRessource.getMaterialInfo().findRessourcesFromNames(this);

					UPackageRessource diffuse = matRessource.getMaterialInfo().getDiffuse();

                    if (diffuse != null) {
						pendingExport.add(diffuse);
						matRessource.replaceWith(diffuse);

                        diffuse.setIsUsedInMap(true);
						diffuse.setUsedInStaticMesh(true);
                    }
                }

				pendingExport.add(matRessource);


                matRessource.setIsUsedInMap(true);
                matRessource.setUsedInStaticMesh(true);
                // change original material name: "<name>"
                // to <packagename>_<group>_<name>_mat
                // or <packagename>_<name>_mat
                // or <name>_mat to fit with max size of 64
                // byte for material name
                return matRessource.getConvertedBaseName();
            }
        }

        return null;
	}

	private File getDummyUAssetFile(){
		// TODO for UE5, make custom dummy uasset file
		return new File(outputGame.getPath() + "/UnrealTournament/Content/RestrictedAssets/Blueprints/Lift/Curves/EaseIn-Out.uasset");
	}

	/**
	 * Delete unused files and convert them to good format if needed. (e.g:
	 * convert staticmeshes to .ase or .fbx format for import in UE4)
	 *
	 * @throws IOException Error reading files
	 */
	private void cleanAndConvertRessources() throws IOException {

		updateMessage("Converting ressource files");
		boolean wasConverted;

		// remove unecessary exported files
		// convert them to some new file format if needed
		// and rename them to fit with "naming" standards
		for (UPackage unrealPackage : mapPackages.values()) {

			for (UPackageRessource ressource : unrealPackage.getRessources()) {

				wasConverted = false;
				List<File> exportedFiles = ressource.getExportedFiles();

				if (exportedFiles == null) {
					continue;
				}

				for (File exportedFile : exportedFiles) {
					if (exportedFile != null && exportedFile.length() > 0) {

						wasConverted = cleanAndConvertRessource(wasConverted, ressource, exportedFile);
					}
				}
			}
		}

		// always keep original .t3d file
		try {
			Files.move(inT3d.toPath(), new File(getOutPath().toString() + File.separator + "myLevel_unconverted.t3d").toPath(), StandardCopyOption.ATOMIC_MOVE);
		} catch (IOException e) {
			logger.warning(e.getMessage());
		}

		updateMessage("Deleting temporary files");

		org.apache.commons.io.FileUtils.deleteQuietly(getTempExportFolder());

		// Create a folder for this map in UE4Editor
		// and copy a simple existing .uasset file so we can see the folder
		// created in UT4 editor ...
		if (isTo(UE4)) {

			// TEMP thingy use custom one if user changed it
			//File wipConvertedMapFolder = new File(UTGames.getMapsFolder(userGameConfig.getRessourceUpdatedPath(), outputGame) + File.separator + getOutMapName());
			File wipConvertedMapFolder = getUt4ReferenceBaseFolderFile();

			Files.createDirectories(wipConvertedMapFolder.toPath());

			logger.log(Level.FINE, "Creating " + wipConvertedMapFolder);

			// copy small .uasset file so the folder will appear in UT4 editor
			File uassetCopy = new File(wipConvertedMapFolder + File.separator + getDummyUAssetFile().getName());

			if (!uassetCopy.exists()) {
				Files.copy(getDummyUAssetFile().toPath(), uassetCopy.toPath(), StandardCopyOption.REPLACE_EXISTING);
			}

			// for each terrain converted copy the UT4X landscape material to output folder
			AtomicInteger landscapeMatIdx = new AtomicInteger();

			this.getT3dLvlConvertor().getConvertedActors().stream().filter(e -> e instanceof T3DUE2Terrain || e instanceof T3DUE3Terrain).forEach(terrain -> {

				// only support 3 terrains
				if (landscapeMatIdx.getAcquire() < 3&& terrain.getChildren() != null && !terrain.getChildren().isEmpty() && terrain.getChildren().get(0) instanceof final T3DUE4Terrain ue4Terrain) {
					final String landscapeMatFilename = "UT4X_LandscapeMat_" + landscapeMatIdx.getAcquire() + ".uasset";

						final File landscapeMat = new File(Installation.getConfFolder() + File.separator + landscapeMatFilename);
						final File landscapeMatCopy = new File(wipConvertedMapFolder + File.separator + landscapeMatFilename);

						if (!landscapeMatCopy.exists()) {
							try {
								Files.copy(landscapeMat.toPath(), landscapeMatCopy.toPath(), StandardCopyOption.REPLACE_EXISTING);
								ue4Terrain.setLandscapeMatFile(landscapeMatCopy);
							} catch (IOException e) {
								logger.log(Level.WARNING, "Error while copying landscapemap file " + landscapeMat);
							}
						}
				}

				landscapeMatIdx.getAndIncrement();
			});

		}
	}

	private boolean cleanAndConvertRessource(boolean wasConverted, UPackageRessource ressource, File exportedFile) {
		try {
		// Renaming exported files (e.g: Stream2.wav ->
		// AmbOutside_Looping_Stream2.wav)
		// move them to non temporary folder
		if (ressource.isUsedInMap()) {

			// Some sounds and/or textures might need to be
			// converted for correct import in UE4
			final File newExportedFile = ressource.convertResourceIfNeeded(logger);

			if (newExportedFile != null) {
				ressource.getExportInfo().replaceExportedFile(exportedFile, newExportedFile);
				exportedFile = newExportedFile;
				wasConverted = true;
			}

			// rename file and move file to /UT4x-Converter/Converted/<MapName>/<Type>/RessourceName
			Path movedRessourceFile = getRessourceUpdatedPath(ressource, exportedFile);


			Files.createDirectories(movedRessourceFile.getParent());

			if (this.exportOption == ExportOption.BY_PACKAGE) {
				File dummyUAssetFileForPackage = new File(getUt4ReferenceBaseFolderFile() + "/" + ressource.getUnrealPackage().getName() + "/" + getDummyUAssetFile().getName());

				if(!dummyUAssetFileForPackage.exists()) {
					Files.createDirectories(dummyUAssetFileForPackage.toPath().getParent());
					Files.createFile(dummyUAssetFileForPackage.toPath());

					Files.copy(getDummyUAssetFile().toPath(), dummyUAssetFileForPackage.toPath(), StandardCopyOption.REPLACE_EXISTING);
				}
			}

			// sometimes it does not find the exported texture (weird)
			if (exportedFile.exists() && exportedFile.isFile()) {
				Files.copy(exportedFile.toPath(), movedRessourceFile, StandardCopyOption.REPLACE_EXISTING);
			}

			if (exportedFile.delete()) {
				logger.fine("Deleted " + exportedFile);
			}

			//exportedFile = newFile;
			ressource.getExportInfo().replaceExportedFile(exportedFile, movedRessourceFile.toFile());

			if (wasConverted) {
				logger.fine("Converted " + ressource.getType().name() + " :" + movedRessourceFile.toFile().getName());
			}
		}
		} catch (Exception e) {
			System.out.println("Error while converting ressource " + ressource.getFullName(true) + " with file " + exportedFile.getName());
			e.printStackTrace();
			logger.log(Level.WARNING, e.getMessage(), e);
		}
		return wasConverted;
	}

	public Path getRessourceUpdatedPath(UPackageRessource ressource, File exportedFile) {
		Path movedRessourceFile = Paths.get(getMapConvertFolder().getAbsolutePath() + "/" + ressource.getType().getName() + "/" + ressource.getConvertedFileName(exportedFile, true));

		// rename file and move file to /UT4x-Converter/Converted/<MapName>/<PackageName>/RessourceName
		if (this.exportOption == ExportOption.BY_PACKAGE) {
			movedRessourceFile = Paths.get(getMapConvertFolder().getAbsolutePath() + "/" + ressource.getUnrealPackage().getName() + "/" + ressource.getConvertedFileName(exportedFile, false));
		}
		return movedRessourceFile;
	}

	public SupportedClasses getSupportedActorClasses() {
		return supportedActorClasses;
	}

	public T3DLevelConvertor getT3dLvlConvertor() {
		return t3dLvlConvertor;
	}

	public void setT3dLvlConvertor(T3DLevelConvertor t3dLvlConvertor) {
		this.t3dLvlConvertor = t3dLvlConvertor;
	}

	public String getOutMapName() {
		return mapName;
	}



	public UnrealEngine getUnrealEngineTo() {
		return UnrealEngine.from(this.getOutputGame().getUeVersion());
	}


	public boolean isFrom(UnrealEngine... engines) {

		for (UnrealEngine engine : engines) {
			if (engine.version == this.getInputGame().getUeVersion()) {
				return true;
			}
		}

		return false;
	}

	public boolean isFrom(String... shortNames) {
		for (String shortName : shortNames) {
			if (shortName.equals(this.getInputGame().getShortName())) {
				return true;
			}
		}

		return false;
	}

	public boolean isTo(String... shortNames) {
		for (String shortName : shortNames) {
			if (shortName.equals(this.getOutputGame().getShortName())) {
				return true;
			}
		}

		return false;
	}

	// used for backward compatibility
	@Deprecated
	public boolean isTo(UTGame... utgames) {
		for (UTGame utgame : utgames) {
			if (utgame.shortName.equals(this.getOutputGame().getShortName())) {
				return true;
			}
		}

		return false;
	}

	public boolean isTo(UnrealGame... utgames) {

		for (UnrealGame utgame : utgames) {
			if (utgame == this.getOutputGame()) {
				return true;
			}
		}

		return false;
	}

	public boolean isTo(UnrealEngine... engines) {

		for (UnrealEngine engine : engines) {
			if (engine.version == this.getOutputGame().getUeVersion()) {
				return true;
			}
		}

		return false;
	}


	/**
	 * Tells if converting UT game using Unreal Engine 1 or 2 is being converted
	 * to some other UT game using Unreal Engine 3 or 4.
	 *
	 * @return true if converting UT game using Unreal Engine 1 or 2 to UT game
	 *         using Unreal Engine 3 or 4
	 */
	public boolean isFromUE1UE2ToUE3UE4() {
		return isFrom(UnrealEngine.UE1, UnrealEngine.UE2) && isTo(UE3, UE4);
	}


	public File getOutT3d() {
		return outT3d;
	}

	public void setConversionViewController(ConversionViewController conversionViewController) {
		this.conversionViewController = conversionViewController;
		addLoggerHandlers();
	}

	public Logger getLogger() {
		return logger;
	}

	/**
	 * <UT4ConverterFolder>/Converted
	 *
	 * @return <UT4ConverterFolder>/Converted
	 */
	private static File getBaseConvertFolder() {
		return new File(Installation.getDocumentProgramFolder() + File.separator + CONV_PATH);
	}

	/**
	 * <UT4ConverterFolder>/Converted/<MapName>
	 *
	 * @return <UT4ConverterFolder>/Converted/<MapName>
	 */
	public File getMapConvertFolder() {
		return new File(getBaseConvertFolder() + File.separator + getInMap().getName().split("\\.")[0]);
	}

	/**
	 * <UT4ConverterFolder>/Converted/<MapName>/Temp
	 *
	 * @return <UT4ConverterFolder>/Converted/<MapName>/Temp
	 */
	public File getTempExportFolder() {
		return new File(getMapConvertFolder() + File.separator + "Temp");
	}

	/**
	 * Texture db info for input game
	 * Allows to get package name from texture name (since ucc batchexport level commandlet does not expor this info)
	 */
	private List<TextureDbFile.TextureInfo> gameTextureDb = new ArrayList<>();



	/**
	 * Find package ressource by simple name
	 *
	 * @param name
	 *            Simple name (e.g: 'bas05bHA')
	 * @param resType
	 *            Ressource type
	 * @return Ressource using that name
	 */
	public UPackageRessource findRessourceByNameOnly(String name, Type resType) {

		UPackageRessource ressource = null;
		name = name.toLowerCase();

		for (UPackage pack : mapPackages.values()) {

			for (UPackageRessource pakRes : pack.getRessources()) {
				if (pakRes.getType() == resType && pakRes.getName().equalsIgnoreCase(name)) {
					ressource = pakRes;
					break;
				}
			}
		}

		return ressource;
	}

	public UPackageRessource getUPackageRessource(String fullRessourceName, T3DRessource.Type type) {
		return getUPackageRessource(fullRessourceName, null, type);
	}

	/**
	 * T3D actor properties which are ressources (basically sounds, music,
	 * textures, ...)
	 *
	 * @param fullRessourceName
	 *            Full name of ressource (e.g: AmbModern.Looping.comp1 )
	 * @param type
	 *            Type of ressource (sound, staticmesh, texture, ...)
	 * @param packageName
	 *            Package Name (e.g: "AmbModern"). Null if don't have this info
	 *            yet
	 * @return Unreal package ressource
	 */
	public UPackageRessource getUPackageRessource(String fullRessourceName, String packageName, T3DRessource.Type type) {

		if (fullRessourceName == null) {
			return null;
		}

		String[] split = fullRessourceName.split("\\.");

		// no package info
		if (packageName == null) {

			// having only name of ressource not which package it belongs to
			// happens for UE1/2 where polygon t3d data only store name
			// so we using the old "ut3 converter" name to package db until
			// finding a better way ...
			if (split.length <= 1) {

				// for ut99 polygon data does not give package info
				if (type == T3DRessource.Type.TEXTURE && inputGame.isUseTexDb() && gameTextureDb != null) {
					String name = split[0];

					final TextureDbFile.TextureInfo ti = gameTextureDb.stream().filter(e -> e.getName().equalsIgnoreCase(name)).findFirst().orElse(null);

					if (ti != null) {
						packageName = ti.getPackageName();

						if (ti.getGroup() != null) {
							fullRessourceName = packageName + "." + ti.getGroup() + "." + name;
						} else {
							fullRessourceName = packageName + "." + name;
						}

					} else {
						fullRessourceName = name;
					}
				}
				// assuming it's from map
				// as seen in CTF-Turbo for staticmeshes from map package
				// does not give full ressource name
				// e.g: StaticMesh=StaticMesh'sm_Lamp_02'
				// but ressource in "CTF-Turbo.StaticMeshes_Lamps.sm_Lamp_02"
				// ...
				// FIXME on exporting ressource get the right group
				else if (isFrom(UE3)) {
					packageName = getMapPackageName();
					fullRessourceName = packageName + "." + split[0];
				}
			} else {
				packageName = fullRessourceName.split("\\.")[0];
			}
		} else {
			if (!fullRessourceName.contains(".")) {
				fullRessourceName = packageName + "." + fullRessourceName;
			}
		}

		// for UT99 with unreal editor not giving package name in t3d resource name
		// force to map package if not present
		// else for Unreal 1 "myLevel" in resource name means it's map as package
		if (packageName == null || "mylevel".equalsIgnoreCase(packageName)) {
			packageName = getMapPackageName();
		}

		// Ressource ever created while parsing previous t3d lines
		// we return it
		if (mapPackages.containsKey(packageName)) {

			UPackage unrealPackage = mapPackages.get(packageName);
			UPackageRessource uPackageRessource = unrealPackage.findRessource(fullRessourceName);

			if (uPackageRessource != null) {
				uPackageRessource.setIsUsedInMap(true);
				return uPackageRessource;
			}
			// Need to create one
			else {
				return new UPackageRessource(this, fullRessourceName, type, unrealPackage, true);
			}
		}

		else {

			// need to create one (unreal package info is auto-created)
			UPackageRessource upRessource = new UPackageRessource(this, fullRessourceName, type, true);

			// need force package name since it might not be the same (e.g: myLevel <-> MyMapName)
			upRessource.getUnrealPackage().setName(packageName);
			mapPackages.put(packageName, upRessource.getUnrealPackage());
			return upRessource;
		}
	}

	@Override
	protected T3DLevelConvertor call() {
		try {
			convert();
		} catch (Throwable e) {
			logger.severe(e.getMessage());
			e.printStackTrace();
		}
		return t3dLvlConvertor;
	}

	public void setScale(Double scale) {
		this.scale = scale;
	}

	public ConversionViewController getConversionViewController() {
		return conversionViewController;
	}

	public void setInMap(File inMap)  {
		this.inMap = inMap;
		this.outPath = null;
		packageExtractors.clear();
		this.mapName = null;
		initialise();
	}

	public Path getOutPath() {
		return outPath;
	}

	public boolean convertTextures() {
		return convertTextures;
	}

	/**
	 * Says if program can convert/export textures. For unreal engine <= 2 we
	 * can still user the stock "ucc.exe" one except for Unreal 2 which always
	 * produces "0" bytes file size but for UUE3/4 need umodel program
	 *
	 * @return <code>true</code> if it's possible to convert texture otherwise
	 *         false
	 */
	public boolean canConvertTextures() {
		return inputGame.getUeVersion() <= UnrealEngine.UE2.version;
	}

	/**
	 * Says if program can convert/export sounds.
	 *
	 * @return <code>true</code> if program can convert sounds
	 */
	public boolean canConvertSounds() {
		return inputGame.getUeVersion() <= UnrealEngine.UE2.version;
	}

	public boolean canConvertMusic() {
		// just a file copy for UT2004 (.ogg files ...)
		if (inputGame.getUeVersion() == UnrealEngine.UE2.version) {
			return true;
		} else {
			return canConvertSounds();
		}
	}

	public boolean convertSounds() {
		return convertSounds;
	}

	public boolean convertStaticMeshes() {
		return convertStaticMeshes;
	}

	public boolean convertMusic() {
		return convertMusic;
	}

	public void setConvertTextures(boolean convertTextures) {
		this.convertTextures = convertTextures;
	}

	public void setConvertSounds(boolean convertSounds) {
		this.convertSounds = convertSounds;
	}

	public void setConvertStaticMeshes(boolean convertStaticMeshes) {
		this.convertStaticMeshes = convertStaticMeshes;
	}

	public void setConvertMusic(boolean convertMusic) {
		this.convertMusic = convertMusic;
	}

	public void setOutMapName(String outMapName) {
		this.mapName = outMapName;
	}

	/**
	 * From map file return map package name E.g: DM-Ranking.ut2 -> DM-Ranking
	 *
	 * @return map package name E.g: DM-Ranking.ut2 -> DM-Ranking
	 */
	public String getMapPackageName() {
		return getInMap().getName().split("\\.")[0];
	}

	/**
	 * Find package used in map by name
	 *
	 * @param name
	 *            Name of package (not case sensitive)
	 * @return Package found
	 */
	public UPackage findPackageByName(String name) {

		UPackage pack = null;

		if (name != null && mapPackages.containsKey(name)) {
			pack = mapPackages.get(name);
		}

		return pack;
	}

	public Map<String, UPackage> getMapPackages() {
		return mapPackages;
	}

	/**
	 * If true for each unconverted actor will create a "Note" actor in
	 * converted level
	 *
	 * @param createNoteForUnconvertedActors
	 *            <code>true</code> Will create note for unconverted actors else
	 *            no
	 */
	public void setCreateNoteForUnconvertedActors(boolean createNoteForUnconvertedActors) {
		this.createNoteForUnconvertedActors = createNoteForUnconvertedActors;
	}

	public File getInT3d() {
		return inT3d;
	}

	public void setInT3d(File inT3d) {
		this.inT3d = inT3d;
	}


	/**
	 * Return ut class filter during conversion if any.
	 *
	 * @return Filtered classes
	 */
	public String[] getFilteredClasses() {
		return filteredClasses;
	}

	/**
	 * Set a filter to UT classes that will be converted. If no filter is set
	 * then all classes that can be converted will be converted.
	 *
	 * @param filteredClasses
	 *            Classes that will be converted (e.g:
	 *            ['Brush','Light','DefensePoint', ...]
	 */
	public void setFilteredClasses(String[] filteredClasses) {
		this.filteredClasses = filteredClasses;
	}

	public boolean hasClassFilter() {
		return filteredClasses != null && filteredClasses.length > 0;
	}

	public boolean isUseUbClasses() {
		return this.useUbClasses;
	}

	public void setUseUbClasses(boolean useUbClasses) {
		this.useUbClasses = useUbClasses;
	}

	public void setNoUi(boolean noUi) {
		this.noUi = noUi;
	}

	public void setExportOption(ExportOption exportOption) {
		this.exportOption = exportOption;
	}

	public ExportOption getExportOption() {
		return exportOption;
	}
}
